<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GPX Viewer with Follow Mode</title>

    <!-- Leaflet CSS -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    />

    <!-- Proj4 for coordinate transformation -->
    <script src="https://cdn.jsdelivr.net/npm/proj4@2.9.0/dist/proj4.js"></script>

    <style>
      body {
        margin: 0;
        font-family: sans-serif;
      }
      #map {
        height: 100vh;
        width: 100%;
      }
      #upload {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 1000;
        background: rgba(255, 255, 255, 0.9);
        padding: 10px 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      }
      #controls {
        text-align: center;
        margin: 10px;
      }
      button {
        padding: 6px 12px;
        font-size: 16px;
        cursor: pointer;
      }
      .arrow {
        transform-origin: center center;
        transition: transform 0.2s linear;
      }
    </style>
  </head>
  <body>
    <div id="upload">
      <h2>Upload GPX File</h2>
      <input type="file" id="gpxFile" accept=".gpx" />
    </div>

    <div id="controls">
      <button id="toggleFollow">Enable Follow Mode</button>
    </div>

    <div id="map"></div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- GPX plugin -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/1.5.1/gpx.min.js"></script>

    <script>
      const map = L.map("map").setView([51.505, -0.09], 13);

      // Tile layer
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution: "Â© OpenStreetMap contributors",
      }).addTo(map);

      // Load fk.json file automatically when page opens
      let jsonPointsData = null;

      // Define coordinate systems
      // RD New (Dutch coordinate system)
      proj4.defs(
        "EPSG:28992",
        "+proj=sterea +lat_0=52.15616055555555 +lon_0=5.38763888888889 +k=0.9999079 +x_0=155000 +y_0=463000 +ellps=bessel +towgs84=565.417,50.3319,465.552,-0.398957,0.343988,-1.8774,4.0725 +units=m +no_defs"
      );

      // WGS84 (GPS coordinates)
      proj4.defs("EPSG:4326", "+proj=longlat +datum=WGS84 +no_defs");

      // Function to convert coordinates to WGS84
      function convertToWGS84(x, y) {
        try {
          // First check if coordinates might already be in WGS84 range
          if (x >= -180 && x <= 180 && y >= -90 && y <= 90) {
            console.log("Coordinates appear to be in WGS84 already");
            return { lng: x, lat: y };
          }

          // Check if coordinates are in typical RD range
          if (x >= 0 && x <= 300000 && y >= 300000 && y <= 700000) {
            console.log("Coordinates appear to be in RD (EPSG:28992)");
            const result = proj4("EPSG:28992", "EPSG:4326", [x, y]);
            return { lng: result[0], lat: result[1] };
          }

          // Check if coordinates might be in Web Mercator (EPSG:3857)
          if (Math.abs(x) > 180 && Math.abs(y) > 90) {
            console.log("Trying Web Mercator (EPSG:3857) conversion");
            proj4.defs(
              "EPSG:3857",
              "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs"
            );
            const result = proj4("EPSG:3857", "EPSG:4326", [x, y]);
            return { lng: result[0], lat: result[1] };
          }

          // If nothing else works, try RD anyway
          console.log("Defaulting to RD conversion");
          const result = proj4("EPSG:28992", "EPSG:4326", [x, y]);
          return { lng: result[0], lat: result[1] };
        } catch (error) {
          console.error("Coordinate conversion error:", error);
          return null;
        }
      }

      fetch("./fk.json")
        .then((response) => response.json())
        .then((data) => {
          console.log("Full fk.json content:", data);

          // Filter for points only (items where geom_type is "Point" or geom_point is not null)
          const pointsOnly = data.result.filter(
            (item) => item.geom_type === "Point" || item.geom_point !== null
          );

          console.log("Points only:", pointsOnly);
          console.log("Number of points found:", pointsOnly.length);

          // Log some sample coordinates to understand the coordinate system
          if (pointsOnly.length > 0) {
            console.log("Sample coordinates from JSON:");
            pointsOnly.slice(0, 3).forEach((point, index) => {
              if (point.geom_point) {
                console.log(
                  `Point ${index}: [${point.geom_point[0]}, ${point.geom_point[1]}]`
                );

                // Test different coordinate system assumptions
                console.log("Testing different coordinate systems:");

                // Test as RD (EPSG:28992)
                const rdResult = convertToWGS84(
                  point.geom_point[0],
                  point.geom_point[1]
                );
                if (rdResult) {
                  console.log(
                    `  Converted to WGS84: [${rdResult.lat}, ${rdResult.lng}]`
                  );
                }

                // Test as if already in WGS84 but swapped
                console.log(
                  `  As WGS84 (direct): [${point.geom_point[1]}, ${point.geom_point[0]}]`
                );
                console.log(
                  `  As WGS84 (swapped): [${point.geom_point[0]}, ${point.geom_point[1]}]`
                );
              }
            });
          }

          // Store for later filtering against GPX
          jsonPointsData = pointsOnly;
        })
        .catch((error) => {
          console.error("Error loading fk.json:", error);
        });

      // Function to calculate distance between two lat/lng points in meters
      function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371000; // Earth's radius in meters
        const dLat = ((lat2 - lat1) * Math.PI) / 180;
        const dLon = ((lon2 - lon1) * Math.PI) / 180;
        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos((lat1 * Math.PI) / 180) *
            Math.cos((lat2 * Math.PI) / 180) *
            Math.sin(dLon / 2) *
            Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }

      // Function to filter points by proximity to GPX track points
      function filterPointsByProximity(
        jsonPoints,
        gpxTrackPoints,
        maxDistance = 50
      ) {
        return jsonPoints.filter((jsonPoint) => {
          if (
            !jsonPoint.geom_point ||
            !jsonPoint.geom_point[0] ||
            !jsonPoint.geom_point[1]
          ) {
            return false;
          }

          // Convert coordinates to WGS84
          const converted = convertToWGS84(
            jsonPoint.geom_point[0],
            jsonPoint.geom_point[1]
          );
          if (!converted) {
            console.warn("Failed to convert coordinates for point:", jsonPoint);
            return false;
          }

          const jsonLat = converted.lat;
          const jsonLon = converted.lng;

          // Check if this point is within maxDistance of any GPX track point
          return gpxTrackPoints.some((gpxPoint) => {
            const distance = calculateDistance(
              jsonLat,
              jsonLon,
              gpxPoint.lat,
              gpxPoint.lng
            );
            if (distance <= maxDistance) {
              console.log(
                `Point ${jsonPoint.id} is ${distance.toFixed(
                  2
                )}m from GPX track point`
              );
            }
            return distance <= maxDistance;
          });
        });
      }

      // Load GPX
      document
        .getElementById("gpxFile")
        .addEventListener("change", function (e) {
          const file = e.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = function (event) {
            const gpxText = event.target.result;

            if (window.gpxLayer) map.removeLayer(window.gpxLayer);

            // Parse GPX to extract track points
            const parser = new DOMParser();
            const gpxDoc = parser.parseFromString(gpxText, "text/xml");
            const trackPoints = [];

            // Extract all trkpt elements
            const trkpts = gpxDoc.querySelectorAll("trkpt");
            trkpts.forEach((trkpt) => {
              const lat = parseFloat(trkpt.getAttribute("lat"));
              const lng = parseFloat(trkpt.getAttribute("lon"));
              trackPoints.push({ lat, lng });
            });

            console.log(
              `Extracted ${trackPoints.length} track points from GPX`
            );

            // Log some sample GPX coordinates
            if (trackPoints.length > 0) {
              console.log("Sample GPX coordinates:");
              trackPoints.slice(0, 3).forEach((point, index) => {
                console.log(`GPX Point ${index}: [${point.lat}, ${point.lng}]`);
              });
            }

            window.gpxLayer = new L.GPX(gpxText, {
              async: true,
              marker_options: {
                startIconUrl:
                  "https://unpkg.com/leaflet-gpx@1.5.1/pin-icon-start.png",
                endIconUrl:
                  "https://unpkg.com/leaflet-gpx@1.5.1/pin-icon-end.png",
                shadowUrl: "https://unpkg.com/leaflet-gpx@1.5.1/pin-shadow.png",
              },
            })
              .on("loaded", function (e) {
                map.fitBounds(e.target.getBounds());

                // Filter JSON points by proximity to GPX track points
                if (jsonPointsData && trackPoints.length > 0) {
                  const nearbyPoints = filterPointsByProximity(
                    jsonPointsData,
                    trackPoints,
                    50
                  );
                  console.log(
                    `Found ${nearbyPoints.length} points within 50m of GPX route:`,
                    nearbyPoints
                  );

                  // Add markers for nearby points
                  nearbyPoints.forEach((point) => {
                    if (
                      point.geom_point &&
                      point.geom_point[0] &&
                      point.geom_point[1]
                    ) {
                      // Convert coordinates to WGS84 for display
                      const converted = convertToWGS84(
                        point.geom_point[0],
                        point.geom_point[1]
                      );
                      if (converted) {
                        const marker = L.marker(
                          [converted.lat, converted.lng],
                          {
                            icon: L.icon({
                              iconUrl:
                                "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png",
                              shadowUrl:
                                "https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png",
                              iconSize: [25, 41],
                              iconAnchor: [12, 41],
                              popupAnchor: [1, -34],
                              shadowSize: [41, 41],
                            }),
                          }
                        )
                          .bindPopup(
                            `<strong>${point.name}</strong><br>ID: ${
                              point.id
                            }<br>RD: [${point.geom_point[0].toFixed(
                              2
                            )}, ${point.geom_point[1].toFixed(
                              2
                            )}]<br>WGS84: [${converted.lat.toFixed(
                              6
                            )}, ${converted.lng.toFixed(6)}]`
                          )
                          .addTo(map);
                      }
                    }
                  });
                }
              })
              .on("addpoint", function (e) {
                const wp = e.point;
                if (wp && wp.getLatLng && wp._name) {
                  wp.bindPopup(`<strong>${wp._name}</strong>`);
                }
              })
              .addTo(map);
          };
          reader.readAsText(file);
        });

      // Location marker
      let userMarker = null;
      let heading = 0;
      let followMode = false;

      // Arrow icon
      const arrowIcon = L.divIcon({
        className: "",
        iconSize: [30, 30],
        iconAnchor: [15, 15],
        html: `<svg class="arrow" width="30" height="30" viewBox="0 0 100 100">
               <polygon points="50,0 90,100 50,75 10,100" fill="blue"/>
             </svg>`,
      });

      // Follow mode toggle
      document.getElementById("toggleFollow").addEventListener("click", () => {
        followMode = !followMode;
        document.getElementById("toggleFollow").textContent = followMode
          ? "Disable Follow Mode"
          : "Enable Follow Mode";
      });

      // Watch position
      if (navigator.geolocation) {
        navigator.geolocation.watchPosition(
          (pos) => {
            const latlng = [pos.coords.latitude, pos.coords.longitude];

            if (!userMarker) {
              userMarker = L.marker(latlng, {
                icon: arrowIcon,
              }).addTo(map);
              if (followMode) map.setView(latlng, 16);
            } else {
              userMarker.setLatLng(latlng);
              if (followMode) map.setView(latlng);
            }
          },
          (err) => {
            alert("Geolocation error: " + err.message);
          },
          {
            enableHighAccuracy: true,
            maximumAge: 1000,
          }
        );
      } else {
        alert("Geolocation not supported.");
      }

      // Handle compass heading
      function handleOrientation(event) {
        if (event.absolute || event.webkitCompassHeading !== undefined) {
          heading = event.webkitCompassHeading || 360 - event.alpha;
          const svg = document.querySelector(".arrow");
          if (svg) {
            svg.style.transform = `rotate(${heading}deg)`;
          }
        }
      }

      if (window.DeviceOrientationEvent) {
        if (typeof DeviceOrientationEvent.requestPermission === "function") {
          DeviceOrientationEvent.requestPermission()
            .then((permissionState) => {
              if (permissionState === "granted") {
                window.addEventListener(
                  "deviceorientation",
                  handleOrientation,
                  true
                );
              }
            })
            .catch(console.error);
        } else {
          window.addEventListener("deviceorientation", handleOrientation, true);
        }
      }
    </script>
  </body>
</html>
